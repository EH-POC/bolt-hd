{
  "component_name": "MediaQuery",
  "component_description": "MediaQuery component lets you render element if given media query matches.",
  "props": {},
  "examples": [
    {
      "example_name": "With render children",
      "example_description": "```jsx live\n<>\n  <Typography.Text mb=\"medium\">Resize window to see effect</Typography.Text>\n  <MediaQuery>\n    {(size) => {\n      switch (size) {\n        case 'small': {\n          return <div>Small</div>;\n        }\n        case 'medium': {\n          return <div>Medium</div>;\n        }\n        case 'large': {\n          return <div>Large</div>;\n        }\n        case 'xlarge': {\n          return <div>XLarge</div>;\n        }\n      }\n    }}\n  </MediaQuery>\n</>\n```",
      "code": "<>\n  <Typography.Text mb=\"medium\">Resize window to see effect</Typography.Text>\n  <MediaQuery>\n    {(size) => {\n      switch (size) {\n        case 'small': {\n          return <div>Small</div>;\n        }\n        case 'medium': {\n          return <div>Medium</div>;\n        }\n        case 'large': {\n          return <div>Large</div>;\n        }\n        case 'xlarge': {\n          return <div>XLarge</div>;\n        }\n      }\n    }}\n  </MediaQuery>\n</>",
      "purpose_description": "The purpose of this example is to demonstrate how to use the MediaQuery component with a render prop pattern to dynamically render different content based on the current size of the viewport. This is particularly useful for creating responsive designs that adapt to different screen sizes.",
      "technical_description": "The example uses a MediaQuery component, which likely listens to changes in the viewport size and provides the current size as a parameter to its child function. The child function is a render prop that receives the current size ('small', 'medium', 'large', 'xlarge') and returns different JSX elements based on this size using a switch statement. This allows the component to render different content dynamically as the window is resized.",
      "patterns_description": "This example demonstrates the use of the render prop pattern, which is a powerful technique in React for sharing code between components using a prop whose value is a function. This pattern allows for more flexible and reusable components. The use of a switch statement to handle different cases of the size parameter is a straightforward way to manage conditional rendering based on the viewport size.",
      "use_cases_description": "This example is particularly useful in scenarios where responsive design is needed, such as in web applications that need to adapt to different devices and screen sizes. It can be used in dashboards, content management systems, or any application where the layout or content needs to change based on the screen size to improve user experience."
    },
    {
      "example_name": "MediaQuery is a polymorphic components",
      "example_description": "MediaQuery lets us specify which React element we want to use for its root. Default component is `React.Fragment`\n```jsx live\n<>\n  <Typography.Text mb=\"medium\">Resize window to see effect</Typography.Text>\n  <MediaQuery as={Typography.Title} level={3}>\n    {(size) => {\n      switch (size) {\n        case 'small': {\n          return 'Small';\n        }\n        case 'medium': {\n          return 'Medium';\n        }\n        case 'large': {\n          return 'Large';\n        }\n        case 'xlarge': {\n          return 'XLarge';\n        }\n      }\n    }}\n  </MediaQuery>\n</>\n```",
      "code": "<>\n  <Typography.Text mb=\"medium\">Resize window to see effect</Typography.Text>\n  <MediaQuery as={Typography.Title} level={3}>\n    {(size) => {\n      switch (size) {\n        case 'small': {\n          return 'Small';\n        }\n        case 'medium': {\n          return 'Medium';\n        }\n        case 'large': {\n          return 'Large';\n        }\n        case 'xlarge': {\n          return 'XLarge';\n        }\n      }\n    }}\n  </MediaQuery>\n</>",
      "purpose_description": "The purpose of this example is to demonstrate how the MediaQuery component can be used as a polymorphic component, allowing developers to specify which React element should be used as its root. This flexibility is useful for adapting the component to different contexts and styling needs without altering its core functionality.",
      "technical_description": "The MediaQuery component in this example is designed to render different text based on the current size of the window. It uses a polymorphic approach, allowing the root element to be specified via the 'as' prop. By default, it uses React.Fragment, but in this example, it is set to use Typography.Title with a level of 3. The component takes a function as its child, which receives the current size ('small', 'medium', 'large', 'xlarge') and returns the corresponding text to be displayed. This is achieved through a switch statement that maps each size to a specific string.",
      "patterns_description": "This example demonstrates the polymorphic component pattern, which is a powerful technique in React for creating flexible and reusable components. By allowing the root element to be specified via a prop, the component can be easily adapted to different use cases without duplicating code. Additionally, the use of a function as a child component is a common pattern in React, enabling dynamic rendering based on state or props, in this case, the window size.",
      "use_cases_description": "This example is particularly useful in responsive design scenarios where the content needs to adapt to different screen sizes. By using the MediaQuery component, developers can easily change the rendered content or its styling based on the current viewport size. This approach is ideal for applications that need to provide a seamless user experience across a wide range of devices, from mobile phones to large desktop screens."
    },
    {
      "example_name": "useMediaQuery",
      "example_description": "Hero Design also provides a hook to use media query in your components, by default it uses `small`, `medium`, `large`, `xlarge` breakpoints. If you want to use less or more breakpoints, pass them into `breakpoints` option config.\n```jsx\n// small | medium | large | xlarge\nconst size = useMediaQuery();\n\n// small | medium\nconst size = useMediaQuery({ breakpoints: ['small', 'medium'] });\n```",
      "code": "// small | medium | large | xlarge\nconst size = useMediaQuery();\n\n// small | medium\nconst size = useMediaQuery({ breakpoints: ['small', 'medium'] });",
      "purpose_description": "The purpose of this example is to demonstrate how to use the `useMediaQuery` hook provided by Hero Design to handle responsive design in React components. This hook allows developers to easily access the current viewport size category based on predefined or custom breakpoints, enabling responsive behavior in the application.",
      "technical_description": "The `useMediaQuery` hook is a custom React hook that returns the current size category of the viewport. By default, it uses four predefined breakpoints: `small`, `medium`, `large`, and `xlarge`. When invoked, the hook listens to changes in the viewport size and updates the returned size category accordingly. The hook can also accept a configuration object with a `breakpoints` property, allowing developers to specify custom breakpoints. This flexibility enables developers to tailor the responsive behavior of their components to specific design requirements.",
      "patterns_description": "This example demonstrates the use of a custom hook to encapsulate logic related to responsive design, which is a common pattern in React applications. By abstracting the media query logic into a hook, the component code remains clean and focused on rendering logic. This approach promotes reusability and separation of concerns, as the responsive logic can be reused across different components without duplication. Additionally, using hooks for responsive design is a best practice in modern React development, as it leverages React's state and lifecycle management capabilities.",
      "use_cases_description": "This example is particularly useful in scenarios where a React application needs to adapt its layout or behavior based on the viewport size. Real-world use cases include responsive navigation menus, grid layouts that adjust the number of columns based on screen size, or components that need to hide or show elements depending on the device type (e.g., mobile vs. desktop). The ability to customize breakpoints makes this hook versatile for various design systems and requirements."
    }
  ]
}